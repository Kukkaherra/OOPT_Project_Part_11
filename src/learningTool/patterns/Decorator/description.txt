The Decorator Pattern allows classes to be extended (implement new functionality) without modifying the original code. The decoratorâ€™s aim is to add its additional behavior and rely on the decorated object to do the rest of the job. Consider a Coffee Shop that sells different kinds of beverages, and has many available condiments. Also for this example, assume the beverages and condiments have a fixed price; how would you implement this? Having a boolean instance variable for each available condiment would force us to modify each of the beverage-classes whenever a new condiment is introduced. But by wrapping an object with a decorator, it is possible to increment the total cost and append the new information to the description without modifying the underlying beverage at all. Remember, because the decorator is inherited from the beverage class, the object is still of the same type even after wrapping it with a decorator.
