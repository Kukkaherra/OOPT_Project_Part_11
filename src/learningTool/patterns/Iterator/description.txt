"The Iterator Pattern allows traversal of the elements of an aggregate without exposing the underlying implementation. It also places the task of traversal on the iterator object, not on the aggregate, which simplifies the aggregate interface and implementation, and places the responsibility where it should be."

By using the iterator pattern, we can implement a shared interface through which we can traverse and access objects of a collection regardless of the type of the collection. That means we can treat Arrays and ArrayLists, for example, the same way, without having to worry about the underlying representation.

The aggregate interface decouples your client from the implementation of your collection of objects. The iterator interface is the shared interface all collections which can be iterated over have to implement. It includes the methods required for traversing over the elements of the collection. You don't have to create your own iterator interface, as java has a built in interface that is a part of the Java util library (java.util.iterator).

The concrete aggregate holds the collection of objects and implements the method to create and return the iterator for that collection. The concrete iterator on the other hand is responsible for managing the current position of the iterator. It should be noted that each aggregate has to instantiate an iterator for itself, if it wishes to iterate over the collection.

The reason different aggregates or types of collections don't or shouldn't have to implement their own iterators has to do with the single responsibility design principle. Every responsibility of a class is an area of potential change. More than one responsibility means more than one area of change. This principle guides us to keep each class to a single responsibility.
