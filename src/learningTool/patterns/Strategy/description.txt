"The Strategy Pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it"

To explain the Strategy Pattern, we'll simplify the term "algorithm" to just "action". Think of ducks, for example. Not all ducks can fly, they don't all quack in the same way, and they might have any number of other differing actions. To include all of them in a superclass would mean that some actions would need to be overwritten to do nothing, some changed, and in the end, it would be a real pain in terms of maintenance. Similarly, implementing all the different actions as interfaces would mean we'd need to go around changing a lot of implementations if we need to change a specific action. This is where strategy pattern comes in. Separating the ducks from their actions by allowing the desired behavior to be set independently of the Duck allows us to introduce a large variety of different actions and easily maintainable code.

The Strategy Pattern follows an object oriented principle of "favoring composition over inheritance". It essentially means that if you design entities to consist of things. Following the composition, these individual parts can be substituted for others, even at runtime. 
