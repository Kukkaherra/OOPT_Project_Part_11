“The Composite Pattern allows us to build structures of objects in the form of trees that contain both compositions of objects and individual objects as nodes. Using a composite structure, we can apply the same operations over both composites and individual objects.”

In Composites the tree structures allow us to represent part-whole hierarchies. Composite also lets clients treat individual objects and compositions of objects uniformly. The fact that both individual objects and composite objects are treated equally, means we can “ignore”the differences between them.

Elements in the tree structure that have child elements are called nodes, they are composite objects. Elements without child elements are called leaves, they are individual objects. In the class diagram the Client uses the Component interface to manipulate the objects in the composition. The Component interface is the shared interface for both composite and leaf nodes. Leaves implement the interface or inherit the abstract class and define the behaviour for individual elements, by implementing the operations the Composite supports. The Composite on the other hand defines behavior of the components that have child elements.

Both the Leaf and Composite elements include operations of each other, meaning Composites include Leaf element operations, and Leaves include operations meant for Composites. The alternative option would be to use two interfaces but we would lose transparency and have to use conditionals and something like the instanceof operator. This is purely a design decision, and doing it differently has its tradeoffs.

When we’re traversing through a tree structure like this, and we might want to print out the data from the nodes and leaves for example, we would need to iterate over the elements. For this we can combine using the Composite pattern and the Iterator pattern, which we will look at later, to create a complete solution.